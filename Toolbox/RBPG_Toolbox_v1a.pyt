#Written by Scott Spurgeon, USACE-ERDC-CHL#scott.l.spurgeon@usace.army.milimport arcpyclass Toolbox(object):    def __init__(self):        self.label = "Representative Beach Profile Generator Toolbox"        self.alias = "RBPG"        self.tools = [Step1, Step2]class Step1(object):    def __init__(self):        self.label = "Step 1: Plot and Align Profiles"        self.description = "This step plots the extracted points and feature points from the dune feature extraction toolbox and aligns profiles. Once alignment is complete the average values are saved to a csv file for Step 2"        self.canRunInBackground = False    def getParameterInfo(self):        # Seaward Limit Input Setup        sl = arcpy.Parameter(            displayName="Seaward Limit",            name="seawardlimit",            datatype="GPVariant",            parameterType="Required",            direction="Input")        # CRI Factors        CRI = arcpy.Parameter(            displayName="CERI Factors",            name="CERI",            datatype="DETable",            parameterType="Required",            direction="Input")        # Extracted Points        extractedpoints = arcpy.Parameter(            displayName="Extracted Points",            name="Extracted Points",            datatype="GPFeatureLayer",            parameterType="Required",            direction="Input")                # Alignment Flag        alignmentflag = arcpy.Parameter(            displayName="Align Profiles?",            name="Alignment Flag",            datatype="GPBoolean",            parameterType="Optional",            direction="Input")                # Alignment Feature Elev        alignmentfeatureelev = arcpy.Parameter(            displayName="Alignment Feature Elevation",            name="Alignment Feature Elevation",            datatype="Field",            parameterType="Optional",            direction="Input")                # Export Folder        outputfolder = arcpy.Parameter(            displayName="Output Folder",            name="Output Folder",            datatype="DEFolder",            parameterType="Required",            direction="Input")                alignmentfeatureelev.parameterDependencies = [CRI.name]        params = [CRI, extractedpoints, sl, alignmentflag, alignmentfeatureelev, outputfolder]        return params    def isLicensed(self):        return True    def updateParameters(self, parameters):        return    def updateMessages(self, parameters):        return    def execute(self, params, messages):        # =============================================================================        # Representative Profile Generator for SBeach Data Generator using CERI and Profile exports from the CERI toolbox.         # Written by Scott Spurgeon, scott.l.spurgeon@erdc.dren.mil        # =============================================================================        import pandas as pd        import numpy as np        import matplotlib.pyplot as plt        import warnings        from arcgis.features import SpatialDataFrame                #Ignore some warnings        warnings.simplefilter(action='ignore', category=pd.errors.PerformanceWarning) #This ignores all performance warnings (comes up when dataframe is built in for loop)        warnings.simplefilter(action='ignore', category=UserWarning) #This ignores all performance warnings (comes up when dataframe is built in for loop)        #Pulling the CERI table into a pandas dataframe        df = pd.DataFrame.spatial.from_table(params[0].valueAsText)        # Pull each value out to be plotted later on along the average profile        MHW_Avg_Elev = df['MHW_Elev'].mean()        MHW_Avg_Range = df['MHW_Rng'].mean()        DT_Avg_Elev = df['DT_Elev'].mean()        DT_Avg_Range = df['DT_Rng'].mean()        FD_Avg_Elev = df['FD_Elev'].mean()        FD_Avg_Range = df['FD_Rng'].mean()        HD_Avg_Range = df['HD_Rng'].mean()        HD_Avg_Elev = df['HD_Elev'].mean()        LL_Avg_Elev = df['LL_Elev'].mean()        LL_Avg_Range = df['LL_Rng'].mean()        #Conversion of alignment flag to boolean        alignment_flag_string = params[3].valueAsText        if alignment_flag_string == 'true':            alignmentflag = True        if alignment_flag_string == 'false':            alignmentflag = False                #Conversion of sl        sl_string = params[2].valueAsText        sl = int(sl_string)                #Pulling in the alignment feature elevation         alignmentfeatureelev_string = params[4].valueAsText        #Based on what the user supplies as the alignment feature there will be a selection of that feature's characteristics        # including the average elevation and the rounded average range        if alignmentfeatureelev_string == 'MHW_Elev':            Alignment_Feature = MHW_Avg_Elev            Alignment_Feature_Range_Rounded = round(MHW_Avg_Range)            arcpy.AddMessage('The Alignment Feature is {0} and the range rounded is {1}'.format(Alignment_Feature,Alignment_Feature_Range_Rounded))        elif alignmentfeatureelev_string == 'DT_Elev':            Alignment_Feature = DT_Avg_Elev            Alignment_Feature_Range_Rounded = round(DT_Avg_Range)        elif alignmentfeatureelev_string == 'FD_Elev':            Alignment_Feature = FD_Avg_Elev            Alignment_Feature_Range_Rounded = round(FD_Avg_Range)        elif alignmentfeatureelev_string == 'HD_Elev':            Alignment_Feature = HD_Avg_Elev            Alignment_Feature_Range_Rounded = round(HD_Avg_Range)        else:            if alignmentflag == True:                arcpy.AddMessage('Error: You must input MHW, DT, FD, or HD as the Alignment Feature Elevation if Alignment is on')               else:                arcpy.AddMessage('Alignment is Off')        # =============================================================================        #%% Pulling Data from Profile Points Dataset        # =============================================================================        #Pulling in profile data and loading it into the dataframe        df = pd.DataFrame.spatial.from_featureclass(params[1].valueAsText)        #Pulling in range values and finding the maximum value for alignment purposes        Range = df['Range'].astype(int)        maxrange = Range.max()        td = pd.Series(range(0,maxrange-1))        td = td.to_frame()        TransID = df['Trans_ID'].astype(int)        for x in TransID.unique():            df_n = df.loc[TransID == x]            df_n = df_n.drop(df_n.columns[0], axis=1)            df_n = df_n.dropna()            if alignmentflag == True:                #Horizontal Alignment                transalignrangerow = df_n.iloc[(df_n['RASTERVALU']-Alignment_Feature).abs().argsort()[:1]] #This pulls out the row where the transect is closest to the alignment feature value                transalignrangenumpy = transalignrangerow['Range'].to_numpy() #This pulls out the range from the above row and turns it into a numpy value                transalignrange = transalignrangenumpy.astype(int)                shiftvalue = Alignment_Feature_Range_Rounded - transalignrange #This subtracts that value from the average range value to get the amount the transect needs to be shifted in the cross shore direction                arcpy.AddMessage('the shift value is {0}'.format(shiftvalue))                                if shiftvalue == 0: #If no shifting is needed, ignore                    arcpy.AddMessage('No Shift Needed for Transect {0}'.format(x))                else: #Otherwise, shift the data as needed                    df_n = df_n.shift(shiftvalue[0])                             rastervalue = df_n['RASTERVALU'].astype(float)            rasterlist = rastervalue.to_list()            numberofnans = maxrange - len(rasterlist)            arcpy.AddMessage('NumberofNans: {0}'.format(numberofnans))            if numberofnans > 0:                 rasterlistextended = np.append(rasterlist, np.repeat(np.nan,numberofnans-1))                td['Transect_{}'.format(x)]=rasterlistextended            else:                td['Transect_{}'.format(x)]=rasterlist[:maxrange-1]                                            td['Average Value']= td.iloc[0:maxrange,1:x].astype(float).mean(axis=1) #Averaging the values for each range value         # =============================================================================        #%% Plotting        # =============================================================================                # Figure 1 is a plot of all profile point data (including the average profile)         # to ensure that the data has been aligned and to be able to visually see where the average chart came from        plt.figure(1)        plt.clf()        plotsx = td.iloc[0:sl,0]        plt1data = td.iloc[0:sl,1:x]        plt.axhline(y=0,color='k',ls='-',lw=2)        plt.plot(plotsx, plt1data)        if alignmentflag == True:                        plt.title("Input Profile Data Aligned to " + alignmentfeatureelev_string[:-5])        else:            plt.title("Input Profile Data, Not Aligned")            arcpy.AddMessage('Alignment Off')        plt.xlabel("Distance from Landward Limit (m)")        plt.ylabel("Elevation (m)")        #Figure 2 plots the average value as well as the extracted morphology points.        averageelevsplotting = td['Average Value'].iloc[0:sl] #Grab the average morphology line data for plotting        plt.figure(2)        plt.clf()        plt.axhline(y=0,color='k',ls='-',lw=2)        plt.plot(plotsx, averageelevsplotting,label = "Average Morphology Line")        x = [MHW_Avg_Range,DT_Avg_Range,FD_Avg_Range,HD_Avg_Range,LL_Avg_Range]        y = [MHW_Avg_Elev,DT_Avg_Elev,FD_Avg_Elev,HD_Avg_Elev,LL_Avg_Elev]        plt.plot(x,y,'g',label = "Average Profile from Extracted Points")        plt.plot(MHW_Avg_Range,MHW_Avg_Elev, 'ro', label = "Extracted MHW Average Location")        plt.plot(DT_Avg_Range,DT_Avg_Elev, 'go', label = "Extracted Dune Toe Average Location")        plt.plot(FD_Avg_Range,FD_Avg_Elev, 'bo', label = "Extracted Front Dune Average Location")        plt.plot(HD_Avg_Range,HD_Avg_Elev, 'mo', label = "Extracted High Dune Average Location")        plt.plot(LL_Avg_Range,LL_Avg_Elev, 'yo', label = "Extracted Landward Limit Average Location")        plt.title("Average Profile")        plt.xlabel("Distance from Landward Limit (m)")        plt.ylabel("Elevation (m)")        plt.legend()        plt.show()                # =============================================================================        #%% Export for Step 2        # =============================================================================                expt = pd.DataFrame()        expt['Distance from Landward Limit'] = plotsx        expt['Elevation'] = averageelevsplotting        expt['Extracted Points X'] = pd.Series(x)        expt['Extracted Points Y'] = pd.Series(y)        expt['MHW Avg Range'] = pd.Series(MHW_Avg_Range)        expt['MHW Avg Elevation'] = pd.Series(MHW_Avg_Elev)        expt['DT Avg Range'] = pd.Series(DT_Avg_Range)        expt['DT Avg Elevation'] = pd.Series(DT_Avg_Elev)        expt['FD Avg Range'] = pd.Series(FD_Avg_Range)        expt['FD Avg Elevation'] = pd.Series(FD_Avg_Elev)                expt['HD Avg Range'] = pd.Series(HD_Avg_Range)        expt['HD Avg Elevation'] = pd.Series(HD_Avg_Elev)        expt['LL Avg Range'] = pd.Series(LL_Avg_Range)        expt['LL Avg Elevation'] = pd.Series(LL_Avg_Elev)                        export_csv = (params[5].valueAsText + '\\Step1Output.csv')        expt.to_csv(export_csv)                returnclass Step2(object):    def __init__(self):        self.label = "Step 2: Create User-Generated Trapezoidal Approximation"        self.description = "This step takes the export from the previous step and allows the user to input their own approximation of the profile and then export their results for SBeach Runs"        self.canRunInBackground = False    def getParameterInfo(self):        # Previous step csv input        s1csv = arcpy.Parameter(            displayName="Step 1 Export CSV",            name="Step 1 Export CSV",            datatype="DETable",            parameterType="Required",            direction="Input")        # Shoreline Elev        ShorelineElev = arcpy.Parameter(            displayName="Shoreline Elevation",            name="Shoreline Elevation",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Berm Elev        BermElev = arcpy.Parameter(            displayName="Berm Elevation",            name="Berm Elevation",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Upland Elev        UplandElev = arcpy.Parameter(            displayName="Upland Elevation",            name="Upland Elevation",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Max Berm Width        MaxBermWidth = arcpy.Parameter(            displayName="Maximum/Current Berm Width",            name="Max Berm Width",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Min Berm Width        MinBermWidth = arcpy.Parameter(            displayName="Minimum Berm Width",            name="Min Berm Width",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Max Dune Width        MaxDuneWidth = arcpy.Parameter(            displayName="Maximum/Current Dune Width",            name="Max Dune Width",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Min Dune Width        MinDuneWidth = arcpy.Parameter(            displayName="Minimum Dune Width",            name="Min Dune Width",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Max Dune Crest Elev        MaxDuneCrestElev = arcpy.Parameter(            displayName="Maximum/Current Dune Crest Elevation",            name="Max Dune Crest Elevation",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Min Dune Crest Elev        MinDuneCrestElev = arcpy.Parameter(            displayName="Minimum Dune Crest Elevation",            name="Min Dune Crest Elevation",            datatype="GPDouble",            parameterType="Required",            direction="Input")                #Max Shoreline X        MaxShorelineX = arcpy.Parameter(            displayName="Maximum/Current Shoreline Cross Shore Position",            name="Max Shoreline X",            datatype="GPDouble",            parameterType="Required",            direction="Input")                #Min Shoreline X        MinShorelineX = arcpy.Parameter(            displayName="Minimum Shoreline Cross Shore Position",            name="Minimum Shoreline X",            datatype="GPDouble",            parameterType="Required",            direction="Input")                #Max Dune Toe X        MaxDuneToeX = arcpy.Parameter(            displayName="Maximum/Current Dune Toe Position",            name="Max Dune Toe X",            datatype="GPDouble",            parameterType="Required",            direction="Input")                #Min Dune Toe X        MinDuneToeX = arcpy.Parameter(            displayName="Minimum Dune Toe Position",            name="Min Dune Toe X",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Max Back of Dune X        DuneXBackMax = arcpy.Parameter(            displayName="Maximum/Current Back of Dune Crest Position",            name="Max Dune X Back",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Min Back of Dune X        DuneXBackMin = arcpy.Parameter(            displayName="Minimum Back of Dune Crest Position",            name="Min Dune X Back",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Back Dune Toe X Max        BackDuneToeXMax = arcpy.Parameter(            displayName="Maximum/Current Back of Dune Toe Position",            name="Max Back Dune Toe X",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Back Dune Toe X Min        BackDuneToeXMin = arcpy.Parameter(            displayName="Minimum Back of Dune Toe Position",            name="Min Back Dune Toe X",            datatype="GPDouble",            parameterType="Required",            direction="Input")                UplandWidth = arcpy.Parameter(            displayName="Upland Width",            name="Upland Width",            datatype="GPDouble",            parameterType="Required",            direction="Input")                # Export Folder        outputfolder = arcpy.Parameter(            displayName="Output Folder",            name="Output Folder",            datatype="DEFolder",            parameterType="Required",            direction="Input")        params = [s1csv, ShorelineElev, BermElev, UplandElev, UplandWidth, MaxBermWidth, MinBermWidth, MaxDuneWidth, MinDuneWidth, MaxDuneCrestElev, MinDuneCrestElev,                  MaxShorelineX, MinShorelineX, MaxDuneToeX, MinDuneToeX, DuneXBackMax, DuneXBackMin, BackDuneToeXMax, BackDuneToeXMin, outputfolder]        return params    def isLicensed(self):        return True    def updateParameters(self, parameters):        return    def updateMessages(self, parameters):        return    def execute(self, params, messages):                #Imports, all are needed        import pandas as pd        import matplotlib.pyplot as plt        from arcgis.features import SpatialDataFrame        from scipy.interpolate import griddata        import warnings        import numpy as np        import math                #ignoring some warnings with plotting        warnings.simplefilter(action='ignore', category=pd.errors.PerformanceWarning) #This ignores all performance warnings (comes up when dataframe is built in for loop)        warnings.simplefilter(action='ignore', category=UserWarning) #This ignores all performance warnings (comes up when dataframe is built in for loop)                        #Get all user inputs as floats and plug them into variables to be used with plotting        ShorelineElev = float(params[1].valueAsText)        BermElev = float(params[2].valueAsText)                UplandElev = float(params[3].valueAsText)                UplandWidth = float(params[4].valueAsText)                BermWidthMax = float(params[5].valueAsText)                BermWidthMin = float(params[6].valueAsText)        DuneWidthMax = float(params[7].valueAsText)                DuneWidthMin = float(params[8].valueAsText)                DuneCrestElevMax = float(params[9].valueAsText)                DuneCrestElevMin = float(params[10].valueAsText)                 ShorelineXMax = float(params[11].valueAsText)                ShorelineXMin = float(params[12].valueAsText)                DuneToeXMax = float(params[13].valueAsText)                DuneToeXMin = float(params[14].valueAsText)                 DuneBackXMax = float(params[15].valueAsText)                DuneBackXMin = float(params[16].valueAsText)                 BackDuneToeXMax = float(params[17].valueAsText)                BackDuneToeXMin = float(params[18].valueAsText)                #Pull in the csv import from step 1, not skipping nulls to ensure all data is pulled in        df = pd.DataFrame.spatial.from_table(params[0].valueAsText,skip_nulls = False)        #Warnings set up to ensure that the script fails if the dune crest elev min or max are too low        if DuneCrestElevMin < UplandElev:            arcpy.AddWarning('The minimum dune crest elevation must be greater than the upland elevation')            return                if DuneCrestElevMin < BermElev:            arcpy.AddWarning('The minimum dune crest elevation must be greater than the berm elevation')            return        if DuneCrestElevMax < UplandElev:            arcpy.AddWarning('The maximum dune crest elevation must be greater than the upland elevation')            return                if DuneCrestElevMax < BermElev:            arcpy.AddWarning('The maximum dune crest elevation must be greater than the berm elevation')            return                    #Setting up the max and min profiles based on user inputs        maxrepprofile = pd.DataFrame({'Range': [(BackDuneToeXMax - UplandWidth),BackDuneToeXMax,DuneBackXMax,(DuneBackXMax + DuneWidthMax),DuneToeXMax,(DuneToeXMax + BermWidthMax),ShorelineXMax],                                      'Elevation': [UplandElev,UplandElev,DuneCrestElevMax,DuneCrestElevMax,BermElev,BermElev,ShorelineElev]})             minrepprofile = pd.DataFrame({'Range': [(BackDuneToeXMin - UplandWidth),BackDuneToeXMin,DuneBackXMin,(DuneBackXMin + DuneWidthMin),DuneToeXMin,(DuneToeXMin + BermWidthMin),ShorelineXMin],                                      'Elevation': [UplandElev,UplandElev,DuneCrestElevMin,DuneCrestElevMin,BermElev,BermElev,ShorelineElev]})                #Putting all of the data into dataframe format for export        df['User Inputted Shoreline Elevation'] = pd.Series([ShorelineElev])        df['User Inputted Berm Elevation'] = pd.Series([BermElev])        df['User Inputted Upland Elevation'] = pd.Series([UplandElev])        df['User Inputted Max Berm Width'] = pd.Series([BermWidthMax])        df['User Inputted Min Berm Width'] = pd.Series([BermWidthMin])        df['User Inputted Max Dune Width'] = pd.Series([DuneWidthMax])        df['User Inputted Min Dune Width'] = pd.Series([DuneWidthMin])        df['User Inputted Max Dune Crest Elevation'] = pd.Series([DuneCrestElevMax])        df['User Inputted Min Dune Crest Elevation'] = pd.Series([DuneCrestElevMin])        df['User Inputted Max Shoreline Cross Shore Position'] = pd.Series([ShorelineXMax])        df['User Inputted Min Shoreline Cross Shore Position'] = pd.Series([ShorelineXMin])        df['User Inputted Max Dune Toe Cross Shore Position'] = pd.Series([DuneToeXMax])        df['User Inputted Min Dune Toe Cross Shore Position'] = pd.Series([DuneToeXMin])        df['User Inputted Max Back Dune Cross Shore Position'] = pd.Series([DuneBackXMax])        df['User Inputted Min Back Dune Cross Shore Position'] = pd.Series([DuneBackXMin])        df['User Inputted Max Back Dune Toe Cross Shore Position'] = pd.Series([BackDuneToeXMax])        df['User Inputted Min Back Dune Toe Cross Shore Position'] = pd.Series([BackDuneToeXMin])                        # =============================================================================        #%% RMSE Calculations between Averaged Profile and User-Drawn Profile        # =============================================================================        #This interpolates the points inputted for the max profile and grids the data between them.        #Effectively, this makes the lines between the scatter plot points into actual data for        #error checking purposes        # f = interp1d(maxrepprofile['Range'],maxrepprofile['Elevation'], kind='cubic')        grid_z0 = griddata(maxrepprofile['Range'],maxrepprofile['Elevation'],df["Distance from Landward Limit"], method='linear')        griddf = pd.DataFrame(grid_z0, columns = ['Value'])        #Setup the RMSE error and calculate         msetrue = df["Elevation"].iloc[0:int(ShorelineXMax)+1].dropna()        msetruenp = msetrue.to_numpy()        msepred = griddf.dropna()        mseprednp = msepred.to_numpy()        mse = np.square(np.subtract(msetruenp,mseprednp)).mean()        RMSE = math.sqrt(mse)        #Update the df (that will be exported) with the RMSE error        df['RMSE Error between extracted data and user inputted approximation'] = pd.Series([RMSE])        #Print the error for the user to know        RMSE_string = str(round(RMSE,2))        arcpy.AddMessage('RMSE Error between Averaged Profile and User Drawn Profile: ' + RMSE_string)                        #final plot        plt.figure(1)        plt.clf()        plt.axhline(y=0,color='k',ls='-',lw=2)        plt.plot(maxrepprofile['Range'],maxrepprofile['Elevation'],color='r',label = 'Maximum/Current Representative Profile')        plt.plot(minrepprofile['Range'],minrepprofile['Elevation'],color='g',label = 'Minimum Representative Profile')        plt.plot(df["Distance from Landward Limit"], df["Elevation"],'b',label = "Average Morphology Line")        plt.plot(df["Extracted Points X"],df["Extracted Points Y"],'m',label = "Average Profile from Extracted Points")        plt.plot(df['MHW Avg Range'],df['MHW Avg Elevation'], 'ro', label = "Extracted MHW Average Location")        plt.plot(df['DT Avg Range'],df['DT Avg Elevation'], 'go', label = "Extracted Dune Toe Average Location")        plt.plot(df['FD Avg Range'],df['FD Avg Elevation'], 'bo', label = "Extracted Front Dune Average Location")        plt.plot(df['HD Avg Range'],df['HD Avg Elevation'], 'co', label = "Extracted High Dune Average Location")        plt.plot(df['LL Avg Range'],df['LL Avg Elevation'], 'yo', label = "Extracted Landward Limit Average Location")        plt.title("Average Profile")        plt.xlabel("Distance from Landward Limit (m)")        plt.ylabel("Elevation (m)")        plt.legend()        plt.show()                #final export to folder        export_csv = (params[19].valueAsText + '\\Step2Output.csv')        df.to_csv(export_csv)        return